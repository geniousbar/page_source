---
title: CSAPP(深入理解计算机系统)
date: 2017-12-02
tags: csapp
---

计算机系统漫游
---------

1. 代码从文本到可执行文件的过程（c语言示例）：
  * 预处理阶段，处理 #inlcude <stadio.h>， #define MAX 100
  * 编译阶段：将文本编译成汇编程序，hello.s
  * 汇编阶段：汇编器将上一步的程序翻译成机器指令。hello.o
  * 链接阶段就：hello 中调用的printf函数，而函数存在一个printf.o 单独的编译完成文件，需要以某种方式合并到hello.o 中。
2. 系统的硬件组成
  * 总线
  * I/O设备
  * 主存
  * 处理器， 指令集合： 加载(复制内容到寄存器）， 存储（从寄存器到存储），操作（加减乘除等计算）， 跳转（覆盖程序计数器PC的数值，执行代码跳转）
  * 缓存， 高速缓存
3. 操作系统如何管理硬件
  * 任何的硬件通过操作系统提供服务， 所有应用程序都是建立在操作系统之上的。
  * OS 的基本功能： 1. 方式硬件被滥用， 2. 提供一套简单一致的机制来控制复杂度而又大相径庭的低级硬件设备。
  * OS 的抽象： 文件 -> IO， 虚拟存储器 -> 主存+磁盘， 进程 -> 处理器，主存，IO设备的抽象
4. 抽象
  * 进程： 计算机科学中最重要并且成功的概念。
    > 提供一种假象， 好像系统上只有这个程序在运行，看上去只有这个程序在使用处理器、主存、和IO设备. 这是通过处理器在进程间切换来实现的。  操作系统实现这种交错执行的机制为 **上下文切换**, 实现进程这个抽象概念需要低级硬件和操作系统软件之间的紧密合作。

  * 线程：每个线程都运行在进程的上下文中，并共享同样的代码和全局数据，服务器对于并行处理的需求，导致线程编程成为越来越重要的编程模型， 一般来说，多线程之间更容易共享数据，也比进程更轻量。
  * 虚拟存储器： 为进程提供了一个抽象、一致的存储空间，称为虚拟地址空间。包括： 程序代码和数据，堆，共享库，栈，内核虚拟存储器。
  * 文件： 字节序列。包括磁盘，键盘，显示器，网络，都可以视为文件。
  * 并行跟并发的区分： 并发: **好像** 同时具有多个活动在系统中。 并行：真正的并行。
  * 抽象： 抽象的使用是计算机科学中最为重要的概念之一，因为，程序员无需了解它内部的工作变可以使用这些代码。在处理器中，指令集结构提供了对实际处理器硬件的抽象。机器代码程序表现的好像是运行在一个一次执行一条指令的处理器上。底层的硬件币抽象描述的要复杂精细的多，它并行的执行多条指令，但又总是与那个简单有序的模型保持一致。


  ![计算机抽象](../images/interface.png)

  **计算机系统中一个重大的主题就是  提供不同层次的抽象表示，来 隐藏实际实现的复杂性**


信息的表示和处理
-------------

因为只是介绍了二进制、无符号数、有符号数、以及小数的表示方法， 计算机教程中都有介绍，所以省略不写了。只是简单的摘录重要的。

1. 在相同长度的无符号和有符号整数之间 进行强制类型转换时候，大多数C语言实现遵循 原则是 底层的位模式不变。而是改变位的解释方法。
2. 编码的存储长度有限。可能导致数值溢出。需要非常注意。
3. 整数和浮点数的表示方法，有所区别，导致， 整数可以进行移位、结合等优化方法，但是浮点数则不行，如 x * y * z 不等于 y * z * x 需要注意


程序的机器级别表示
------------------

**精通细节是理解更深和更基本概念的先决条件， 所以魔鬼隐藏在细节之中。***

1. 机器代码的产生过程
 > 机器代码， 用字节序列编码低级的操作，包括处理数据、管理存储器、读写存储设备上的数据、以及利用网络通信。 编译器机基于编程语言的原则、目标机器的指令和操作系统遵循的原则， 经过一系列的阶段产生机器代码。GCC C语言编译器以汇编代码的形式产生输出，然后调用 汇编器和链接器从而根据汇编代码生成可执行的机器代码。

3. 抽象：
  * 指令集体系结构（ISA）： 屏蔽了处理器的硬件实现，将指令的执行描述为，简单的顺序执行(处理器的硬件远远比描述的精细复杂)
  * 存储抽象： 抽象成一个大的字节数组，存储器的实现是，将多层硬件存储器和操作系统软件的结合

2. 主要内容：
  * 了解C语言中的控制结构， 比如if while switch 语句的实现方法。
  * 过程的实现， 包括程序如何维护一个运行栈来支持过程间数据和控制的传递以及局部变量的存储
  * 数组、结构、联合这样的数据结构的实现方法

4. 指令集：
  * 指令操作数
  * 源数据： 常数、寄存器、存储器
  * 类型： 立即数（常数）、寄存器、存储器
  * C 语言的指针就是地址，间接引用指针就是将该指针放在一个寄存器中，然后在存储器引用中，使用这个寄存器， 局部变量通常保存在寄存器中。
  * 数据传送指令: mov
  * 算数逻辑操作： add， sub， imul， sal， shl， leal, imull, mull, idivl, divl
  * 控制：条件码，跳转指令，test, sete, sets, setg etc, cmp, jmp, **条件码一般使用比较、算数、直接设定三种方式， 跳转指令则利用，条件码来进行跳转或者间接跳转**
  * 栈： push, pop

5. C 语言 控制结构 汇编表示
    * while, for **一般是先将 for 循环转变为等价的 while 循环，while 循环 套用固定的汇编代码 模式。**

      ```text
         do
          body-statement
          while(test-expr)

        loop:
          body-statement
          t = test-expr;
          if(t)
            goto loop;
        done:


        while(test-expr)
          body-statement

          t = test-expr;
          if(!t)
            goto done;
        loop:
          body-statement
          t = test-expr;
          if(t)
            goto loop;
        done:
      ```
    * switch 的实现
      使用跳转表 实现，来达到 执行时间跟 开关数量无关。

    * 条件传送指令
      因为现代处理器的流水线设计，导致在条件判断时候，才能确定下一条执行指令的位置，而导致按照顺序执行 准备的代码可能被抛弃，而对应的准备工作则变为了浪费。 而 条件传送 指令先计算出条件操作的两种结果，然后根据条件来选择满足的结果。从而避免了 因为跳转指令 带来的资源浪费。另一方面现代处理器都采用了 分支预测 逻辑，来试图猜测每条跳转指令是否被执行。（处理器设计试图达到 90%的正确率），正确的预测可以没有代价，然而额错误的预测则会带来严重恩惩罚，大约 20-40 的时钟周期的浪费，导致性能严重下降。
      举例： 例如简单 三目运算符， x > y ? x+y : x-y, 当两个表达式具有副作用的时候则不能应用。

6. 结构实现:
  * 数组分配和访问： 基本实现为, 在存储器中分配一个连续的 T A[N], L * N 字节的连续大小的空间。 L为T类型的字节大小。而C语言中数字指针的实现（ptr ++ ）则实现为单纯的 地址运算。嵌套数组 则以 行优先、列优先 的方式进行展开。
  * Struct 的实现， 变量为 首地址 + 偏移量。
  * 数据对齐： 计算机系统对 基本数据结构类型的大小做了限制，8的倍数等。这种 对齐限制，简化了 处理器和存储系统之间的硬件设计。

7. 过程实现
  **过程调用 包括数据传递（过程参数、返回值）、控制跳转。在进入是为过程的局部变量分配空间，并在退出时候释放这些空间。**
    * 简单指令:
      转移控制： call, leave, ret.
      call: 将返回地址入栈（call之后的下一条命令的地址） 2. 跳转到被调用的过程处。
      ret： 从栈中弹出地址，并跳转到此位置。需要将栈指针指向call指令存储的放回地址的位置（需要自己控制）
      leave: &nbsp;&nbsp;&nbsp; movl %ebp, %esp; popl %ebp 为ret 返回做好准备工作

      如果使用整数，指针作为返回值的话，可以使用%eax传递。（其他的呢？）
      寄存器使用： 寄存器是计算中公用的资源。为了保证 被调用者不会覆盖调用者时候用的寄存器的数值。需要遵守规范。
      %eax, %edx, %ecx 调用者保存寄存器， %ebx, %esi, %edi 被调用者保存寄存器。 需要调用者与被调用者配合来保护共享的寄存器内容。

    * 实现过程:
    函数调用过程的两个寄存器 %ebp(帧指针), %esp（栈指针） 帧指针保存当前过程的最高位置，%esp则向下增长， 用于分配必要的地址空间，调用函数参数等。 在调用时， 首先压入调用参数，返回地址， 压入%ebp, 调用后，将 %ebp 重置为当前的%esp， 标记确定当前的 函数的最高地址。返回时, movl %ebp, %esp; popl %ebp; ret; 恢复调用函数之前的样子。天生的具有递归属性。

    ![计算机抽象](../images/call_stack.png)

    * 什么时候需要帧指针:
      * 局部变量太多，不能都存在在寄存器中
      * 有些局部变量是数组或者结构
      * 函数用取地址操作符&，来计算一个局部变量的地址
      * 函数必须将栈上的某些参数传递到另一个函数
      * 在修改一个被调用者保存寄存器之前，需要保存它的状态

    * X86-64 中对于过程的 一些具体优化：
       * 参数通过寄存器传递到过程，而不是在栈上，消除了在栈上存储和检索值的开销
       * call 指令将一个64位的返回地址存储在栈上
       * 许多函数不需要栈帧，只有那些不能将所有局部变量存储在寄存器中的函数才需要在栈上分配空间
       * **没有帧指针，作为替代，对栈位置的引用相对于栈指针。**

8. C 语言 指针
  * 每个指针都对应一个具体的类型： 指针类型不是机器代码中的一部分，C语言提供的一种抽象，地址运算，来避免寻址错误。
  * 每个指针都有一个值， 这个值是某个指定类型对象的地址。
  * 指针用& 运算符创建
  * 运算符 * 用于指针的 间接引用
  * 数组与指针紧密关联
  * 指针类型转换： 只改变类型，而不是值
  * 指针可以指向函数，之函数机器代码中的 第一条 指令地址。将


  > C语言跟汇编指令 的差别很大，在汇编语言中，各种数据类型之间的差距很小，程序以指令序列来表示。每条指令是一个单独的操作。编译器必须提供多条指令来产生和操作各种数据结构，来实现像条件、循环、和过程这样的控制结构、抽象机制。

处理器体系结构
---------

>  一个处理器支持的指令和指令的字节编码成为它的 指令集体系结构 （ISA）ISA的编辑器编写者和处理器设计人员之间提供了一个**概念抽象层。现代处理器的实际工作方式可能跟ISA 隐含的计算模型大相径庭**

1. 目的
  * 设计 Y86 处理器，首先是基于顺序的、功能正确的处理器设计
  * 创建一个流水线化的处理。处理器可以同时执行五条指令的不同阶段

2. Y86 指令编码，
    * 具体的描述了， 指令的机器字节表示。字节编码必须有唯一 的解释，任何一个字节序列要么是一个唯一的指令序列的编码，要么就不是一个合法的字节序列。 每条指令的第一个字节码都有唯一的代码和功能组合。给定这个字节，我们就可以决定所有的其他的附加字节的长度和含义。这个性质确保处理器可以无二义性的执行目标代码程序。反汇编程序的翻译解释，就是如此。

      ![编码示例](../images/command_sample.png)

    > RISC（精简指令集） 和 CISC（复杂指令集）：简单的指令集形式可以产生更搞笑的代码， 实际上，许多加到指令集中的高级指令很难被编辑器产生，所以也很少被利用。90年代，沉沦逐渐平息，无论是淡出的RISC，还是单纯的CISC都不如结合两者思想精华的设计。今天的RISC机器的指令表，已经有数百条指令，几乎与  精简指令集机器 的名字不相符了。那种将实现细节暴露给机器级程序的思想已经被证明是目光短浅的。（RISC做过这样的事情？）

3. Y86 的实现：
    1. 拆分指令为阶段：
      * 取指： 取指阶段从存储器读取指令字节，地址为程序计数器的值，从指令中 抽取出 指令的，icode， ifun， 操作的字符， rA， rB, 常数
      * 译码： 译码阶段从寄存器文件读入最多两个操作数，得到值， valA， valB等。
      * 执行： ALU运算，
      * 访存： 可以将数据写入存储器，或者从存储器读出数据。
      * 写回： 将结果写回到寄存器文件
      * 更新PC： 将PC设置成为下一条指令的地址

        >  在设计硬件时候， 一个非常简单而一致的结构是非常重要的。降低复杂度的一种方法是，让不同的指令共享尽量多的硬件，因为在硬件上复制逻辑快比用软件来处理困难的多。

        ![指令阶段](../images/command_flow.png)

    2. 硬件结构 (SEQ)
      * 组合电路从本质上讲，不存储任何信息，他们只是简单的响应输入信号。 产生等于输入的某个函数的输出。
      * 存储设备： 时钟寄存器： 存储单个位，或字，时钟信号控制寄存器加载输入值
      * 随进访问寄存器： 存储多个字，用地址来选择该读或者写。应用有：寄存器文件， %eax etc

        ![指令阶段](../images/register.png)

    5. 流水线通用原理：
        > 流水线化的一个重要特性就是增加了**系统的吞吐量**（单位时间内服务的顾客的总数），代价是可能稍微的增加了延迟（服务一个用户所需的时间）。举例来说， 一个客户需要沙拉，在一个非流水线话的服务中，非常简单，只需要在沙拉阶段停留。但是在一个流水线化的服务中，则需要无谓的其他阶段的等待。

        * 流水线的局限性： **运行时钟的速率是由最慢的阶段的延迟限制的**。所以对于硬件设计者来说，将系统计算设计成 具有相同延迟的阶段 是一个严峻的挑战。
        * 预测下一个PC：
           1. 流水线的设计目的是 每个时钟周期 都发射一条指令，也就说每个时钟周期都有一条新的指令进入执行阶段并最终完成。
           2. 要做到这一点就 需要在取出当前指令之后，马上确认下一条指令。
           3. 如果取出的指令是条件分支指令，要到几个周期之后，才能确定是否要选择分支。(jxx)类似的是ret
           4. 分支预测和处理预测错误
        * 流水线冒险： 将流水线引入一个带反馈的系统，当相邻指令间存在相关时会导致出现问题， 这些相关可能会导致流水线产生计算错误，称为**冒险**。
          1. 数据相关: 下一条指令会用到这一条指令计算出的结果。数据冒险
          2. 控制相关: 一条指令要确定下一条指令的位置。例如执行条件跳转。控制冒险
            ![指令阶段](../images/flow_command.png)

        * 控制逻辑：
          1. 处理ret
          2. 加载使用冒险
          3. 预测错误的分支： 在分支逻辑发现不应该选择分支之前，分支目标处的几条指令已经进入到了流水线中，必须从流水线中舍弃这些操作
          4. 当一条指令发生异常，需要禁止后面的指令更新 程序员可见状态，并且在异常指令到达写回阶段时，停止执行。
          控制逻辑的优化，有些繁杂，需要结合 时钟周期、代码执行阶段来 具体分析。

        * 通用的冒险简单解决办法：
          1. 暂停来避免冒险： 让一条指令停留在译码阶段，直到他需要的操作数的指令通过了写回阶段，这样来避免数据冒险。 虽然这一机制实现起来相当简单，但是得到的性能却并不好，一条指令更新一个寄存器，紧随其后的指令使用被更新过的寄存器的事情非常普遍，为了保证正确的执行，在其中不断的加入nop，导致流水线暂停长达三个周期，这严重的降低了 整体的吞度量。
          2. 转发来避免冒险： 将结果直接从一个流水线阶段**传到较早阶段**的技术称为 数据转发， 也就是较早的反馈到需要的阶段。比如 译码阶段。



        * 未考虑的方面：
          1. 多周期指令，一些复杂的操作 例如乘法、除法。一种方法是 同步到特殊单元来进行处理，流水线继续处理其他指令(并发执行)。但是**不同的单元操作需要是同步**的，以避免 出错。
          2. 存储器接口： 涉及到存储器的命令，具体来说是 是以存储器位置的虚拟地址来引用他们，这涉及到， 地址翻译（将虚拟地址翻译成物理地址），然后对存储器进行操作。在有些情况，被引用的存储器位置储存在硬盘上，硬件会产生一个 缺页 异常信号，这个异常会导致处理器调用操作系统的缺页代码，然后访问磁盘数据到高速缓存中，访问 磁盘就需要数百万个 时钟周期。所以其导致的性能下降是非常严重的。

    6. 总结
      * ISA指令集结构，提供了代码到处理器具体实现的一层抽象。也就是一条指令执行完了，下一条指令执行。
      * 流水线化 通过让不同的阶段并行操作，改进了系统的吞度量性能，然而我们必须小心，以便流水线化 执行与程序的顺序执行得到相同的程序行为。
