---
title: 现代操作系统
date: 2021-05-21
tags: os, linux
---

### 现代操作系统：


抽象是管理复杂性的关键， 好的抽象可以把一个 不可能管理的任务 分为 两个可管理的部件。 抽象的定义和实现 + 用这些抽象解决的问题。
操作系统的任务 就是 创建好的抽象 并实现和管理它所创建的抽象对象。抽象内容是理解操作系统的关键。



作为资源管理者的操作系统：

资源管理包括 以下两种不同方式实现 多路复用（共享）资源：时间上 复用 + 空间上复用 。 

时间复用 例子 比如 打印机， 问题： 如何决定下一个执行哪个任务？ 以及 任务运行的时间

空间复用 比如硬盘、内存。 问题： 任务之间的公平， 保护问题。

网络操作系统 与 分布式 操作系统： 网络操作系统 与 单处理器的操作系统没有本质区别。 分布式操作系统 则 与 集中式系统 有本质的区别，用户根本不知道自己的文件存储在什么地方，任务在那个机器上运行，网络中的通信延迟导致 分布式算法必须能够适应信息不完备、信息过时、信息错误的情况。这与 单机形成对比， 单机系统中操作系统掌握着完全的信息。因此 需要更复杂的处理器调度算法  来获得 更大的并行度。



处理器： 

访问内存 以 得到指令或数据 的时间   要比执行指令花费的时间 长得多。所以 CPU内部都保存 一些用来 保存关键变量+临时数据的寄存器。
程序计数器： 下一条指令的内存地址
堆栈指针： 内存中当前栈的顶端，用于 函数调用中的 参数传递
程序状态字 PSW program status word： 包含  条件码 + cpu优先级 + 用户态内核态 + 控制位 （在系统调用中、IO 中 PSW 作用非常重要）

指令流水线： 将 指令 分解为  取指 + 解码 + 执行 多个单元 并行执行的 结构。
超标量CPU： 此设计中， 存在多个执行单元比如： 1个CPU 用于整数计算 + 1个cpu用于浮点数计算。 该设计 可能导致  程序中的指令 经常不按照 顺序执行。在多数情况下， 硬件负责  保证这种运算结果与顺序执行指令的结果相同，但是，应有部分 复杂情形 需要操作系统 来处理。

内核态 + 用户态： PSW 中存在 二进制 位 控制该模式，内核态： cpu 可执行 指令集中的任何一条命令， 用户态： 则 只能执行指令集的一个子集。（比如IO 操作） 为了从操作系统获得服务， 用户必须 使用 系统调用  以陷入内核 调用 操作系统。TRAP 指令 从用户态切换到内核态。


计算机使用陷阱 而非 一条指令来执行 系统调用， 而其他的多数陷阱  是由硬件引起的，用于 异常的发生，入 除以 0。

多线程 和 超线程：  多线程 允许 cpu 保持两个不同的线程状态， 然后在纳秒级别内 进行切换，多线程 并非 真正的并行处理， 在同一时刻 只有一个进程运行，但是线程的切换时间 为纳秒级别。




多核CPU 
GPU：  Graphics Processing Unit 上万个微核组成的处理器， 擅长大量的并行简单运算，很难编程， 虽然GPU对于操作系统 非常有用（比如加密 ，图像处理 etc） 但是 操作系统本身 不太可能 运行在GPU上。

#### 存储器：  寄存器  高速缓存  主存  磁盘 
任何缓存系统 都需要考虑的问题： 
1. 何时把一个新的内容放到缓存
2. 把新的内容 放在缓存的哪一行上
3. 在需要时， 应该把那个内容村缓存移走
4. 应该把新移走的内容放在某个较大存储器的何处

通常通过 所 引用内存地址的 高位计算 应该使用的缓存行。比如 对于 64 字节的 4096个 缓存行 以及 32 位地址， 其中 6-17位 用来定位缓存行，而 0-5 则用来确定缓存行中的字节。

缓存是好方法： 现代cpu有两个L1缓存，第一个 L1 总是在 CPU中， 用来将 已解码 的指令调入CPU的执行引擎。 第二个L1 则存放 频繁使用的数据字节。
二级缓存L2 用来存放最近使用的若干兆内存字节，L2 延迟 1-2个时钟， L1 则没有延迟


在多核芯片中， 设计师 需要确定缓存的位置， Intel 中多核 CPU 共享L2缓存， AMD 则 每个核 都有自己的 L2缓存。Intel 需要设计 更复杂的缓存侧率， AMD 则需要在 缓存一致上 存在困哪。


内存： RAM random access Memory： 
ROM: read only memory
Flash Memory:介于  RAM 与 磁盘之间， 与磁盘存储器不同， 如果 flash 擦除次数过多， 就会被磨损。
CMOS: 用于保存时间 和日期，还可以用来保存 配置参数 等，比如 那个是启动磁盘。
磁盘： 
固态硬盘： 数据存储在Flash memory (闪存)中, 应该是一份 大的 Flash。
虚拟内存：  将程序放在磁盘上，而将主内存作为一种缓存， 用来保存频繁访问的区域。能够提供大于内存 的 ”内存地址“ MMU 是其实现中的重要一环。

缓存+ MMU 对于系统的性能 具有重要的影响，程序间上下文切换， 需要修改MMU的配置，将 需要同步的数据 从内存写回到 磁盘中。


IO 设备： 包括： 设备控制器  +  设备本身， 控制器 从操作系统接受指令，完成数据的处理。 控制器的任务是为操作系统提供一个简单的接口， 来处理 设备提供的数据。

设备控制器的不同，导致需要 不同的 设备驱动程序。 并 为不同的操作系统提供 相应的驱动程序。

大部分的缺东程序 都需要装入操作系统中，这样他可以在 内核态 运行， 但是其也可以在 内核外运行。 现代的Linux与Windows 也的确对该种方式提供了一定的支持，但绝大部分 驱动程序 依然需要在内核态运行， 非常少的 现代系统 能够在云浒苔运行全部驱动程序。

在用户态运行的驱动程序 必须能够 以某种受控的 方式访问设备，然后这并不容易。


将设备驱动程序 装载到 操作系统有三个方法： 1. 将内核与驱动程序重新链接， 然后重启操作系统， 2） 在操作系统文件中设定一个入口，并通知该文件需要一个设备驱动程序， 然后重启系统， 在启动中， 操作系统 去寻找所需的设备驱动程序 并将其装载 （Windows 工作方式） 3） 操作系统在运行时 接受新的设备驱动程序 并立即 将其安装好， 无需重启， 即是热插拔， USG IEEE 1394设备。

输入+输出的三种方式： 1）忙等待： 用户程序发出一个系统调用，内核将其翻译成对应的 设备驱动程序 调用， 然后设备驱动程序 在一个连续不断的循环中检查设备，查看该设备是否万和城呢够了工作， 当IO 接手后， 设备驱动程序 将数据送到指定的地方， 并返回，然后操作系统将控制返回给 调用者，确定为 占据CPU， CPU 会一直轮训 设备知道对应的IO操作完成。 2）  设备驱动程序 启动设备并且让该设备在操作完成时 发出一个中断， 设备驱动程序在这个时候 返回， 操作系统 阻塞调用者，并进行其他工作， 当设备驱动程序 检测到该设备完成时候，将发出一个中断通知操作完成。其中中断是一个非常重要的概念，IO 分为三步， 1） 设备驱动程序 通过写设备寄存器通知设备控制器做什么，然后 设备控制器 启动该设备， 当设备控制器完成操作 2） 使用特定的总线发送信号给中断控制器芯片 3） 中断控制芯片 接受中断，他会在CPU芯片的一个管脚上声明， 4） 中断控制器将该设备的编号 放到总线上，这样 CPU可以读取总线，并指导那个设备完成了操作。 中断 处理程序：  ...  d第三种） 使用特殊的直接存储器访问 (Direct Memory Access, DMA) 芯片， 它可以 控制内存和某些控制前 之间的位流， 而无需 持续的CPU 干涉，cpu 对dma芯片 进行设置， 说明 需要传送的字节数、有关设备、和内存地址 以及操作方向， 接着启动DMA 当DMA芯片完成时，它会 引发一个中断，。

中断： 中断会发生在非常不合适的时刻， 比如另外一个中断程序正在运行时发生，如果此时接受中断 可能导致 中断程序的递归处理。所以cpu 会关闭中断并在稍后在开启中断，中断关闭时： 任何已经发出中断的设备，可以继续保持其中断信号，但是cpu不会被中断，直到中断再次启用为止， 如果多个设备发生了中断，则 中断控制器 将决定先处理那个中断， 通常这取决于 事先赋予每个设备的静态优先级，最高优先级的设备得到优先处理，其他的设备则等待。


总线：单总线（IBM PC） 因为 处理器以 传输 需求的提升被废弃。
PCIe： 其之前的总线 都是并行 且共享的。即： 共享总线架构， 多个设备使用一些相同的导线传递数据，因为多个设备同时需要发送数据时，需要进行仲裁来决定哪一个设备优先使用。其传输方式 是”并行的“ 即 通过多条导线发送数据的每一个字，例如 一个32位 数据通过 32条并行的导线进行发送。 PCIe 则使用分离的端到端的链路，进行串行总线架构，通过一套 被称为 数据通路的链路传递集合了所有位 的一条消息，类似网络包。 即： 同时可以多个设备共享使用总线。

USB (universal serial bus) 是用来将所有的慢速设备 与计算机进行连接的。USB 是一种集中式总线， 其根设备 每1ms 轮训一次IO 设备，看是否有消息收发， usb 1.0 处理  12Mb/s, 2.0 提高到 480Mb/s 3.0 则可以达到 不小语言  5Gb/s 的速率。

在即插即用的IO设备之前， 每个IO卡 都有一个固定的 中断请求级别 和 用于 其IO寄存器的固定地址， 比如 键盘 中断级别为1， 并使用0x60-0x64 的IO地址， 即插即用 所做的操作 即是： 系统 自动的收集有关IO设备的信息，集中赋予 中断级别和 IO地址，然后通知设备控制器其所使用的数值， 这项工作 与 计算机的启动密切相关。


操作系统分类： 
1. 大型机操作系统  主要面向多作业的同时处理， 多数这样的作业 需要大量的IO能力， 系统主要提供三类服务： 批处理、事务处理、分时。事务处理系统负责大量小的任务， 比如航班预订任务， 每个业务量很小，但是 系统需要每秒处理上千个业务。在部分领域 大型机系统 正在被 Linux 取代
2. 服务器操作系统： 服务器可以是 大型的个人计算、工作站、甚至是大型机， 他们通过网络为若干个用户服务，。
3. 多处理器操作系统： 将大量CPU链接成单个系统。 根据连接和共享方式的不同，这些系统称为 并行计算机 、多计算机、多处理器。个人计算机也开始普及 多核芯片。
4. 个人计算机操作系统
5. 掌上计算机操作系统： 
6. 嵌入式操作系统
7. 传感器节点操作系统：  许多用途需要微小传感器的节点网络。比如森林火灾探测，气象探测器。 此类传感器 能源资源有限。 每个节点上运行一个小型但是真实的操作系统，通常操作系统是事件驱动的，可以相应外部事件 或者基于内部的时钟进行周期性检测，该系统必须小而简单，InyOS 是一个知名的该类操作系统
8. 实时操作系统： 系统的特征是将时间作为关键参数，比如工业过程控制系统，焊接机器人 焊接的太早 或者太晚 都有可能造成物品 损坏，所以需要在规定的时间内进行操作， 这就是硬实时系统。另一个则是软实时系统， 即： 偶尔的超时是可以接受的。
9. 智能卡系统： 比如包含一块cpu芯片的信用卡


操作系统概念：
进程： 正在执行的程序，容纳一个程序所需要的所有信息的容器。
进程表： 操作系统中存储 每一个进程有关的所有信息 放在一张表中：进程表


