---
title: Little java & Shell
date: 2020-09-15
tags: week
---

## A Little Book on Java 的总结
#### Basic
1. 编译 与 运行
编译: javac First.java 产生一个 First.class 文件
运行：java First 将运行 编译之后 First.class
* java  编译器 将 源代码 中的每个 class 转变为 对应的 class file 并存储 其 字节码
* 有 main 函数的 class才能够运行，一个项目中存在多个class 有 main 函数 是为了 将 项目分为不同的 可以运行的单元 方便测试
2. 基本类型
* Number, float, double, int
* Character: char a = ’a’; 
* Boolean: boolean true and false
* Strings: String title = "A Little Book on Java";
* Array: datatype[] ArrayName = new datatype[ArraySize]; 当 使用 index 超过 数组边界 时 会发生 ArrayIndexOutOfBoundsException 错误
3. 流程控制语句
* while loop
```java
while <boolean-expression>
  statement
```

* for loop 
```java

for (initial-expression, boolean-expression, increment-expression) st  atement
```
* if 
```java

if (boolean-expression)
  statement
else if (boolean-expression) 
  statement
else
  statement
```
* break;
4.  抽象机制
5. Procedures
* its name,
* what kinds of parameters it expects (if any),
* what kind of result it might return. 
6. class
* Syntax of Class Declarations
```java
class Hello{
}
```
* main method; java foo a b c, params as args array
```java
class Foo {
  public static void main(String args[]){
      /* Body of main */
  }
}
```
* static variable & function and usage
```java
class Foo {
  static int name;
  public static void showFoo(){
  }
}

classname.methodname(parameters); // static method usage
classname.variablename;           // static variable usage
```
* Visibility Issues （可见控制）: Public data and code is visible to all classes, while private data and code is visible only inside the class that contains it.

7. The Object Concept
* The State of an Object (Instance variables)
```java
class PointIn3D{
  //Instance Variables
  private double x;
  private double y;
  private double z;
}
```
* Constructors
```java
class PointIn3D{
  private double x;
  private double y;
  private double z;

   //Constructors
  //This constructor does not take parameters
  public PointIn3D(){
    /* Initializing the fields of this object to the origin,
       a default point */
    x = 0;
    y = 0;
    z = 0;
  }

  //This constructor takes parameters
  public PointIn3D(double X, double Y, double Z){
    /* Initializing fields of this object to values specified by
       the parameters */
    x = X;
    y = Y;
    z = Z;
  }
}
```
* Creating an Object
```java
//Creates a PointIn3D object with coordinates (0, 0, 0)
new PointIn3D();
//Creates a PointIn3D object with coordinates (10.2, 78, 1) new PointIn3D(10.2, 78, 1);
```
* Object References
```java
ReferenceType ReferenceName;

PointIn3D p = new PointIn3D(1, 1, 1);
```
* Accessing the Fields of an Object
```java
 ReferenceName.FieldName;
```
*  The Behavior of an Object
```java
  ObjectReference.InstanceMethodName(Parameter-List)
```

* The this reference: Inside an instance method, this is a reference to the object on which the instance method is invoked. Inside a constructor, this refers to the object that the constructor just created.

```java

public PointIn3D(){
  this.x = 0;
  this.y = 0;
  this.z = 0;
}
public double getX(){
  return this.x;
}

```

* Inheritance: extends, super can use in subtype to call supertype methods

8. Rules for Method Lookup and Type Checking.
* First the rules. Remember that there are two phases: compile time, which is when type checking is done and run time, which is when method lookup happens. Compile time is before run time.
* The type checker has to say that a method call is OK at compile time.
* All type checking is done based on what the declared type of a reference to an object is.
* Subtyping is an integral part of type checking. This means if B is a subtype of A and there is a context that gets a B where A was expected there will not be a type error.
* Method lookup is based on actual type of the object and not the declared type of the reference.
* When there is overloading (as opposed to overriding) this is resolved by type-checking.

```java
class myInt {
    private int n;
    public myInt(int n){
        this.n = n;
    }
    public int getval(){
        return n;
    }
    public void increment(int n){
        this.n += n;
    }
    public myInt add(myInt N){
        return new myInt(this.n + N.getval());
    }
    public void show(){
        System.out.println(n);
    }
}

class gaussInt extends myInt {
    private int m;  //represents the imaginary part
    public gaussInt(int x, int y){
        super(x);
        this.m = y;
    }
    public void show(){
        System.out.println("realpart is: " + this.getval() +" imagpart is: " + m);
    }
    public int realpart() {
        return getval()
            ;}
    public int imagpart() {
        return m;
    }
    public gaussInt add(gaussInt z){
        return new gaussInt(z.realpart() + realpart(),
                            z.imagpart() + imagpart());
    }
    public static void main(String[] args){
        gaussInt kreimhilde = new gaussInt(3,4);
        kreimhilde.show();
        kreimhilde.increment(2);
        kreimhilde.show();
        System.out.println("Now we watch the subtleties of overloading.");
        myInt a = new myInt(3);
        gaussInt z = new gaussInt(3,4);
        gaussInt w;
        myInt b = z;
        myInt d = b.add(b); //this does type System.out.print("the value of d is:

        // error is this
        // w = z.add(b);// will not type check
        // w = b.add(z); will not type check
        w = ( (gaussInt) b).add(z);//this does type check System.out.print("the value of w is: ");
        w.show();
        myInt c = z.add(a); //will this typecheck? System.out.print("the value of c is: ");
        c.show();
    }
}

```
9. The Exception Object
*  分为两类： unchecked exceptions and checked exceptions.
*  所有的exception 都发生在 runtime， 因为不是的话，要啥编译检查？
*  Unchecked exceptions 与  checked exception 的区别主要在于： Unchecked exceptions happen because of the programmer’s carelessness，也就是说  unchecked exception 是可以预防的，可以避免的。两个主要的 unchecked exception 主要有： rrayIndexOutofBoundsException and NullPointerException
*  所有其他的非 unchecked exception 再是：checked exceptions， 连个主要的exception 有 FileNotFoundException and IOException.
10. 创建 新的 exception
* 新创建的 exception 应该继承 exception 或者 任何 除 RunTimeException 之外的 子类。 因为 新创建的 exception  为 checked exception 
* An exception is thrown to indicate the occurrence of a runtime error. Only checked exceptions should be thrown, as all unchecked exceptions should be eliminated. 意思是： 只有 checked exceptions 需要throw 声明， unchecked exception 因为无法预测，只能 尽量消除掉。（If a method’s header does not contain a throws clause, then the method throws no checked exceptions.）
11. Throwing an Exception
```java
public static void main(String[] args) throws IOException,
                                              FileNotFoundException
```
* A method’s header advertises the checked exceptions that may occur when the method executes
* An exception can occur in two ways: explicitly through the use of a throw statement or implicitly by calling a method that can throw an exception 意思是：异常产生有两种方式：1. 直接抛出异常 2. 调用 能够抛出异常的函数
12. Catching an Exception: catch 异常的方式同其他 语言一致， 即是 不断的递归的 解开栈，以找到合适的 catch。如果无法找到适合的 catch 则  使用默认的 default exception handler 来捕获异常，所以default exception handler 是在哪一层？main 层面吗？
```java
try{
   code that could cause exceptions
}
catch (Exception e1){
   code that does something about exception e1
}
catch (Exception e2){
   code that does something about exception e2
}
```

## A Little Book on Shell 
#### 差用 command
1. file cp mv mkdir rm ln 
其中ln  命令 ln file link, 默认 创建 hard link， ln -s file link 才 为 soft link， soft link 同样增加 file 的link count
2. Working with Commands (type which  help man apropos info whatis alias)
| command | meaning                                           |
|---------|---------------------------------------------------|
| type    | Indicate how a command name is interpreted        |
| which   | Display which executable program will be executed |
| help    | Get help for shell builtins                       |
| man     | Display a command's manual page                   |
| apropos | Display a list of appropriate commands            |
| info    | Display a command's info entry                    |
| whatis  | Display one-line manual page descriptions         |
| alias   | Create an alias for a command                     |

1. commands 的来源： 
* An executable program: 例如 /usr/bin 下面的 可执行文件，
* A command built into the shell itself.： bash 支持的内建 的 命令
* A shell function： shell 函数 Shell functions are miniature shell scripts incorporated into the environment
* An alias： Aliases are commands that we can define ourselves, built from other commands.

2.  man 详细内容： Display a Program's Manual Page。 手册内容 被分为 几个 章节， 出了 使用 man command, 之外 可以使用 man 1 command 来显示 User commands 章节
| section | contents                                       |
|---------|------------------------------------------------|
| 1       | User commands                                  |
| 2       | Programming interfaces for kernel system calls |
| 3       | Programming interfaces to the C library        |
| 4       | Special files such as device nodes and drivers |
| 5       | File formats                                   |
| 6       | Games and amusements such as screen savers     |
| 7       | Miscellaneous                                  |
| 8       | System administration commands                                               |

3. apropos – Display Appropriate Commands 展示相关的 命令。通过  apropos ls 可以获得 lscpu, lshw, 等一系列 命令
4. whatis – Display One-line Manual Page Descriptions:  展示一行关于 command的简单描述
5. info 另一种展现形式的 man
5. alias: alias name='string' 来构建 名为 name 的command line， type name 可以获得 name 对应的 具体string 内容

#### Redirection
1. cat sort uniq grep wc head tail tee(Read from standard input and write to standard output and files)
2. command line  数据流 有： 标准输入 标准输出 标准错误输出，即： stdin, stdout, stderr, 0, 1, 2
3. 重定向 stdout， 使用 > 来将 输出 重定向到 file 中，file中内容将被覆盖。  >>  将 数据重定向 到file中，不覆盖 追加到 file 末尾中
4. 重定向 stderr, 类似 重定向 stdout 使用 2>, 2>> 进行 标准错误输出 的数据重定向
5. 将stdout & stderr 重定向 到一个 file 中：
* ls -l /bin/usr > ls-output.txt 2>&1 ， 注意 其中的 2>&1 的写法，以及， > 与 2>&1 的顺序， 其中原因，为shell 语法需要 控制 两次重定向 打开的是同一个文件
* ls -l /bin/usr &> ls-output.txt 也可以这样 &> 代表 stdout stderr， ls -l /bin/usr &>> ls-output.txt 则代表 将stdout stderr 数据流 追加到 文件中
6. Disposing of Unwanted Output:  ls -l /bin/usr 2> /dev/null 将 数据流 重定向 到 /dev/null 则可以起到忽略 数据流的作用
7. 重定向 stdin, 使用 < 来重定向 stdin 从 键盘 到 file 上， 但是并不是特别有用（很少用到）
8. Pipelines： 使用 pipe operator | 将 一个command 的标准输出  输送 到 一个command 的标准输入中。 command1 | command2
9. Pipelines 与 重定向的 区别： 重定向只能 定向到 file， 而 pipelines 则可以 重定向到  一个command

#### Seeing the World as the Shell Sees It
1. 扩展 Expansion: how a simple character sequence, for example *, can have a lot of meaning to the shell. The process that makes this happen is called expansion. With expansion, we enter some- thing and it is expanded into something else before the shell acts upon it. 也就是 说 在 传递 参数给 command， command 接收参数处理前，会被 进行处理，该处理过程 即是： expansion。
2. echo 是如何 显式化  看到 expansion 结果的 重要方式
3. Pathname Expansion （路径扩展）： 如下释义：
```shell
[me@linuxbox ~]$ ls
Desktop ls-output.txt Pictures Templates Documents Music Public Videos

[me@linuxbox ~]$ echo D*
Desktop Documents

[me@linuxbox ~]$ echo *s
Documents Pictures Templates Videos

[me@linuxbox ~]$ echo [[:upper:]]*
Desktop Documents Music Pictures Public Templates Videos

[me@linuxbox ~]$ echo /usr/*/share
/usr/kerberos/share /usr/local/share

```
4. Arithmetic Expansion: $((expression)), expression 是 算术表达式， 操作数 只能是整数， 操作符 有 +, -, *, /, %, **
```shell
[me@linuxbox ~]$ echo $(($((5**2)) * 3))
```

5. Brace Expansion: 
```shell
[me@linuxbox ~]$ echo Front-{A,B,C}-Back
Front-A-Back Front-B-Back Front-C-Back

[me@linuxbox ~]$ echo Number_{1..5}
Number_1 Number_2 Number_3 Number_4 Number_5

[me@linuxbox ~]$ echo {01..15}
01 02 03 04 05 06 07 08 09 10 11 12 13 14 15

[me@linuxbox ~]$ echo {001..15}
001 002 003 004 005 006 007 008 009 010 011 012 013 014 015

[me@linuxbox ~]$ echo {Z..A}
Z Y X W V U T S R Q P ON M L K J I H G F E D C B A


[me@linuxbox ~]$ mkdir Photos
[me@linuxbox ~]$ cd Photos
[me@linuxbox Photos]$ mkdir {2007..2009}-{01..12} 
[me@linuxbox Photos]$ ls
2007-01 2007-07 2008-01 2008-07 2009-01 2009-07 2007-02 2007-08 2008-02 2008-08 2009-02 2009-08 2007-03 2007-09 2008-03 2008-09 2009-03 2009-09 2007-04 2007-10 2008-04 2008-10 2009-04 2009-10 2007-05 2007-11 2008-05 2008-11 2009-05 2009-11 2007-06 2007-12 2008-06 2008-12 2009-06 2009-12
```
6. Parameter Expansion

```shell
[me@linuxbox ~]$ echo $USER 
me
```
7. Command Substitution: 子命令， 允许在表达式中 执行子命令 并展开. $(command sub)
```shell
[me@linuxbox ~]$ echo $(ls)
Desktop Documents ls-output.txt Music Pictures Public Templates Videos
```

8. Quoting: 可以用来控制 是否进行 扩展 展开。
* 下面两个示例：

```shell
[me@linuxbox ~]$ echo this is a    test
this is a test

[me@linuxbox ~]$ echo The total is $100.00
The total is 00.00
```
注意 这两个 的存在的问题： 1. 第一个中 shell 将 params 中多余的空格 去掉了， 即是： 'a    test'中多余的空格， 因为 shell 将 通过 空格 分隔 参数，认为 a test  为两个参数。 2. $100.00 展开为了 00.00 是因为 $1 不存在的缘故

* Double Quotes： 将参数 加上 "" 之后， ""内的内容 将被视为 一个 参数， 但  parameter expansion, arithmetic expansion, and command substitution 依然 有效。
如下示例:
```shell
[me@linuxbox ~]$ ls -l two words.txt
ls: cannot access two: No such file or directory
ls: cannot access words.txt: No such file or directory

[me@linuxbox ~]$ ls -l "two words.txt"
-rw-rw-r-- 1 me me 18 2016-02-20 13:03 two words.txt [me@linuxbox ~]$ mv "two words.txt" two_words.txt
```

```shell
[me@linuxbox ~]$ echo this is a    test
this is a test

[me@linuxbox ~]$ echo "this is a   test"
this is a   test




(calvagrant@precise64:~$ echo $(cal)
September 2020 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30

vagrant@precise64:~$ echo "$(cal)"
   September 2020
Su Mo Tu We Th Fr Sa
       1  2  3  4  5
 6  7  8  9 10 11 12
13 14 15 16 17 18 19
20 21 22 23 24 25 26
27 28 29 30

```
* Single Quotes： 单引号 中的内容 扩展 全部 失效。
* Escaping Characters： \

| escape sequence | meaning         |
|-----------------|-----------------|
| \a              | Bell            |
| \b              | Backspace       |
| \n              | Newline         |
| \r              | Carriage return |
| \t              | Tab             |

9. Signals: Signals are one of several ways that the operating system communicates with programs
* kill: The kill command doesn't exactly “kill” processes: rather it sends them signals 
 kill [-signal] PID...



| keyboard | signal |
|----------|--------|
| Ctrl-c   | INT    |
| Ctrl-z   | TSTP   |





| Number | Name  | Meaning                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|--------|-------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1      | HUP   | Hangup. This is a vestige of the good old days when terminals were attached to remote computers with phone lines and modems. The signal is used to indicate to programs that the controlling terminal has “hung up.” The effect of this signal can be demonstrated by closing a terminal session. The foreground program running on the terminal will be sent the signal and will terminate.                                                                                                           |
| 2      | INT   | Interrupt. This performs the same function as a Ctrl-c sent from the terminal. It will usually terminate a program.                                                                                                                                                                                                                                                                                                                                                                                    |
| 9      | KILL  | Kill. This signal is special. Whereas programs may choose to handle signals sent to them in different ways, including ignoring them all together, the KILL signal is never actually sent to the target program. Rather, the kernel immediately terminates the process. When a process is terminated in this manner, it is given no opportunity to “clean up” after itself or save its work. For this reason, the KILL signal should be used only as a last resort when other termination signals fail. |
| 15     | TERM  | Terminate. This is the default signal sent by the kill command. If a program is still “alive” enough to receive signals, it will terminate.                                                                                                                                                                                                                                                                                                                                                            |
| 18     | CONT  | Continue. This will restore a process after a STOP or TSTP signal. This signal is sent by the bg and fg commands.                                                                                                                                                                                                                                                                                                                                                                                      |
| 19     | STOP  | Stop. This signal causes a process to pause without terminating. Like the KILL signal, it is not sent to the target process, and thus it cannot be ignored.                                                                                                                                                                                                                                                                                                                                            |
| 20     | TSTP  | Terminal stop. This is the signal sent by the terminal when Ctrl-z is pressed. Unlike the STOP signal, the TSTP signal is received by the program, but the program may choose to ignore it.                                                                                                                                                                                                                                                                                                            |
| 3      | QUIT  | Quit                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 11     | SEGV  | Segmentation violation. This signal is sent if a program makes illegal use of memory, that is, if it tried to write somewhere it was not allowed to write.                                                                                                                                                                                                                                                                                                                                             |
| 28     | WINCH | Window change. This is the signal sent by the system when a window changes size. Some programs , such as top and less will respond to this signal by redrawing themselves to fit the new window dimensions.                                                                                                                                                                                                                                                                                            |
* example, kill -number | -Name 也即是说 kill 可以接受 number 或者 显示的名称
```shell
[me@linuxbox ~]$ kill -1 13546
[me@linuxbox ~]$ kill -SIGINT 13608
```
