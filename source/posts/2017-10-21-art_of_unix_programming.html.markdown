---
title: Art of UNIX programming
date: 2017-10-21
tags: unix, linx, art
---

The Art of unix programming
--------

哲学
---------
##### 哲学基础：

   > unix 哲学并不算是一种正规设计方法， 不打算从计算机科学的理论高度产生出完美的软件， 那些毫无动力、松松垮垮的，薪水微薄的程序员，能在短短期限内，如同神灵附体般的创造出稳定而又新颖的软件， 这只不过是经理人永远的梦呓罢了。  (社会经济学基础)
   unix 哲学，是自下而上的，注重实效，立足于丰富的经验，你不会在正规的方法学和标准中找到她，她更接近与隐性的 半本能知识，UNIX 文化所传播的 专业经验。

  * <<Notes on C programming>> 中表述的Unix哲学：
    1. 你无法判断程序会在什么地方耗费运行时间，瓶颈经常会出现在想不到的地方，所以别急于胡乱找个地方改代码，除非你已经证实哪儿就是瓶颈所在。
    2. 估量，在没有对代码进行估量，别去优化速度。
    3. 花哨的算法在n很小的时候通常很慢，而n通常很小，花哨算法的常数复杂度很大，除非你确定n总是很大，否则不要使用花哨算法。
    4. 花哨算法相比于简单算法，通常更容易出bug，更难实现，尽量使用简单的算法配合简单的数据结构
    5. 数据压倒一切，正确的算法不言自明，编程的核心是数据结构，而不是算法。
    6. 没有原则 6
    **Ken Thompson 对第4点进行了，强调， 拿不准就穷举**

  * Unix 本身的体现:
    1. 模块原则： 使用简洁的接口拼合简单的部件 计算机编程的本质是控制复杂度。要编制复杂的软件而又不至于一败涂地的唯一方法就是降低其整体复杂度----- 用清晰的接口把若干简单的模块组合成一个复杂软件，如此一来，多数问题，只会局限于局部，而不是牵一发而动全身。
    2. 清晰原则： 清晰胜于机巧
    3. 组合原则： 设计时考虑拼接组合
      多数程序都尽可能采用过滤器的形式， 即将一个输入的简单文本流处理为一个简单的文本流输出.
    4. 分离原则： 策略同机制分离，接口同引擎分离
    5. 简洁原则： 设计要简洁，复杂度能低就底
    6. 吝啬原则： 除非确无它法， 不要编写庞大的程序
    7. 透明性原则： 设计要可见， 以便于审核和测试
    8. 健壮原则： 健壮源于透明性与简洁
    9. 表示原则： 把知识深入到数据以求逻辑质朴而健壮
      数据要比编程逻辑更容易驾驭，在设计中，你应该主动的将代码的复杂度转移到数据中
    10. 通俗原则： 接口设计避免标新立异
      最少惊奇原则
    11. 缄默原则： 如果一个程序没什么好说，就沉默
    12. 补救原则： 出现异常是，立马退出并给出错误信息
    13. 经济原则： 宁化机器一份，不花程序员一秒
    14. 生成原则： 避免手工hack， 尽量编写程序生成代码
    15. 优化原则： 雕琢之前先得有原型，跑之前先学会走
      过早优化是万恶之源， 先只做原型，在进行细琢，优化之前先确保能用。
    16. 多样原则： 绝不相信所谓的不二法门，
    17. 扩展原则： 设计招眼未来，未来总是比预想快
      设计代码时候， 需要很好的组织， 让将来的开发者增加新功能是无需拆毁或重建整个架构，当然这个原则并不是说你能随意的增加根本用不上的功能。而是建议在编写代码时候考虑未来的需要，使以后增加功能比较容易，程序结合更灵活。
      其实其中很不容易取舍。
    18. KISS keep it simple, stupid
    19. 如果不确定什么是对的，那么就只做最少的工作，确保任务完成就行，至少知道知道什么是对的。（善用工具，尽可能的将一切都自动化）

模块性: 保持清晰，保持简洁
-------------------

  > 代码划分，又一个自然的层次体系， 一开始，一切都是机器吗，最早的过程语言引入了子程序来划分代码的概念，再后来发明了独立地址空间和可以互相通讯的进程，今天，习以为常的把程序系统分布到个个主机上。

  **要编写复杂的软件又不至于一败涂地的唯一方法： 用定义清晰的接口把若干简单模块组合起来，如此一来，多数问题只会出现在局部。**
  1. 封装和最佳模块的大小： 模块直接通过应用程序编程接口(API) 来进行通信。
    1. 实现层面API，阻止各自的内部细节被其他模块知晓。
    2. 设计层面， API，定义了真个系统（验证API是否定义良好，试着使用纯人类语言来描述设计，能够把事情说清楚？先开始定义接口，进行描述，然后开始实践，使用代码阐述设计。）
    3. 模块过大或者过小都会造成更多的bug， 400-800 之间的代码是最佳点。
  2. 紧凑性和正交性：
    1. 紧凑性： 一个设计是否能够被人脑理解，需不需要操作手册，引导指南？（功能集合）
    2. 正交性： 有助于是复杂设计也能紧凑的最重要特性之一， 纯粹的设计中，任何操作都应该是没有副作用的。（不知道为什么是使复杂设计紧凑的重要特性，而不是，将模块解耦？所以模块越紧凑越 少耦合）《程序员修炼之道》对其中有很深入的讨论。
    3. SPOT原则（Single Point of Truth, DRY，Don't repeat yourself）, 保持任何一个知识点，在系通中是唯一的，明确的。
      如果有大量的样板式代码，是不是可以用单一的高层次的表现形式来生成呢?
  3. 自顶向下设计和自底向上设计
    1. 区分： 问问设计是否围绕 **主事件循环** 组织的。还是围绕着主循环可能调用的所有操的服务库组织的。自顶向下的设计者通常先考虑程序的主事件循环，然后才插入具体的事件。自底向上通常考虑封装具体的任务，然后再按照某种次序将这些操作粘合在一起。
    2. 应该双管齐下，自底向上中，能够很好的封装操作原语，从而易于变动，重用底层代码，但是容易做与逻辑无关的工作。自顶向下：可能面临应用逻辑需要的跟真正能够实现的操作原语不同。从而让然封装底层的代码操作。
    3. 双管齐下的设计下：就需要胶合层的出现，来缓解冲突。
  4. unix 和 面向对象
    1. 面向对象编程中，作用于具体的数据结构的函数，和数据一起封装在 可视为单元的一个对象中。非OO中，数据跟函数的联系变的毫无规律。
    2. OO的设计理念在 图形系统，图形用户界面中得到非常多的认可。然而，其他领域则很难发现有多少显著的优点。
    3. OO语言鼓励 『复杂的抽象层次』， 在简单事情中，使事情变得很复杂。使程序员容易陷入过度分层的抽象中，过多的层次破坏了透明性。无在头脑中理清楚代码到底在干什么、如何运行的。

好协议产生好实践
---------------

透明性：来点光（Let There Be light）**最有效的方法： 就是不要在具体操作的代码上叠放太多的抽象层**
------------

  **需要思考的问题:**
  1. 程序调用层次最大的静态深度是多少？
  2. 代码是否具有强大、明显的不变性质。不变性质帮助人们推演代码和发现有问题的情况
  3. 各个函数是否正交？是否有太多的特征标记和模式位，使得一个调用要完成多个任务，完全避免模式标志会导致混乱， 里面包含太多的一模一样的代码，但是频繁的使用模式标志更容易产生错误。（代码中常见）  
  4. 程序的数据结构或者分类和他们所代表的外部实体之间，是否存在一对一的映射？（不必要，设计中不必一对一）
  5. 是否容易找到给定函数的部分代码？不论单个模块，函数，需要花多少时间读懂？
  6. 代码是增加了特殊情况还是避免了特殊情况？ 每一个特殊情况可能对任何其他特殊情况产生影响和隐含的冲突，特殊情况是的代码更难以理解。
  7. 代码简单最好，但是如果代码很好的解决了以上问题，则代码也可以复杂。而且不会对维护人员造成认知负担。

多道程序设计： 分离进程为独立的功能
------------
  > Unix 最具特点的程序模块化技法： 就是将大型程序分解成为多个协作进程。但是，几乎没有好的实践方法。尽管将程序划分成协作进程带来了全局复杂度的降低，蛋代价是我们必须更多的关注在进程间传递消息和命令的协议设计。和 通信各方设计状态机的问题。

  1. **Unix为多进程提供的有：**
    1. 降低多进程 生成的开销
    2. 提供方法、IO、管道、消息传递、套接字 简化进程通信
    3. 提倡使用能有管道、套接字传递的简单、透明的文本数据格式
  2. 进程： 为了降低复杂度，而非为了利用并发提升性能。线程： 为了提高性能，然而，线程并不是降低而是提高的全局复杂度。除非万不得已，不要使用线程。
  3. Unix IPC 方法分类：
    1. shell调用其他程序，这种情形的要点在于， 专门程序在运行时不需要跟父进程交流，只要任意一方接受了 另外一个程序的输入。
    2. 管道、重定向、过滤器： 管道线中的所有阶段的程序是并发运行的。注意到这一点很重要，每一段在等待前一段的输出作为输入。管道已经成为老古董，被套接字取代。
    3. 从进程
    4. 对等进程间通讯： 通常意味着数据能够自由的双向流动。
      * 临时文件： 文件名字冲突（shell脚本中的管理实在临时文件命中包含'$$'，这个shell变量将被展开为载入shell进程的ID， 从而保证文件名的唯一性）
      * **信号： Unix信号是一种软中断形式，每个信号对接受进程产生默认作用（杀掉它），进程可以声明 信号处理程序，让信号处理程序覆盖默认行为，信号最初被涉及到Unix中，最初是最为操作系统就某些错误或关键事件通知程序的一种方式， 举例来说， SIGHUP信号，会在会话结束时被发送给每一个该指定终端会话启动的程序，例： 在用户键入中断（Ctrl-c）时候， 发送给当前每一个连接键盘的程序，然而，信号经常被用作，守护程序的控制通道，随着信号IPC经常使用的一种技法是所谓的pidfile， 需要信号的程序会向已知的位置写入一个包含进程ID的文件(/var/run)其他程序可以通过该文件来获取PID， 如果守护程序只允许一个实例运行，该pidfile， 也作为隐含的文件锁使用。**
      * 套接字： 一种封装网络数据访问的方法， 使用协议族来告诉网络层如何解释套接字的名称， AF_UNIX作为同一台机器上两个进程之间的通信方式.
      * 共享内存： 要求生产者和消费者都必须在一个机器上，但是如果通信进程能够访问同一块物理内存，则共享内存为最快的信息传递方法。需要处理竞争和死锁问题.
      * 要避免的问题和方法
        1. 废弃的Unix IPC方法， System V IPC， Steams
        2. **远程过程调用（RPC）， 最成功的RPC应用，是网络文件系统，都是那些在应用定义域上本来就只涉及很少量简单数据类型的应用。支持RPC的理由通常是， 允许更丰富的接口，但是更不简介，（Unix 强烈赞成使用透明，可显的接口， 这是Unix文化不断坚持文本协议的动力）。RPC旺旺更多延迟的原因有： a： 无法准确估算一个指令调用会涉及到多少数据的列表和散列，b：RPC模型鼓励程序员忽视网络交易成本，造成网络时间消耗。**
    6. 线程： 共享全局内存，在这个共享地址空间管理竞争和临界区的任务相当困难，增加整体复杂度。随着锁定机制复杂度的增加意外交互作用所造成的竞争和死锁机会也会增加。锁定共享数据结构以防止互相干涉的开销非常昂贵，最关键的难题在于，各个系统中实现的标准，没有标准，所以不可能进行移植。
    7. 线程的使用应该是最后一招而不是第一招，如果能够使用优先的共享内存和信号量，使用SIGIO的一部I/O，poll，select 而不是使用线程，那就保持简单。
    8. **线程、远程过程调用、重量级的面向对象设计结合使用的时候，非常危险，如果你被邀请加入到使用这三者的项目中，逃之夭夭并不丢面子（快屁股走人，但是现在的似乎并不少，因为大家实在是现有的稳定的软件API，进行隔离，并没有自己写bug ಥ_ಥ）**
    9. 编程是控制复杂度。能够管理复杂度的工具是好工具，但是如果不是，扔掉！永远不要忘记这一点，它是UNIX智慧的重要组成部分。

微型语言：
---------
  > 对软件错误模式进行大量研究得出的一个一致的结论就是： 程序员每百行代码出错率，和所使用的编程语言在很大程度上相关。更高级的语言可以使用更少的行数完成更多的任务，也意味着更少的bug.

生成： 提升规格说明的层次
-----------

  > 人类更善于肉眼观察数据，而不是推到控制流程。不同的方式在透明性和清晰性方面具有非常显著的差别。数据比程序更容易驾驭。尽可能的把设计的复杂度从程序代码中转移到数据中是个很好的实践。

  1. 数据驱动编程
    需要把代码跟代码作用的数据结构划分清楚。
    跟面向对象区分是： 数据驱动编程中，数据不仅仅是某个对象的状态，实际上还定义了程序的控制流程。 b：OO首先考虑的封装，而数据驱动编程看中的事编写尽可能少的固定代码。

配置： Starting on the Right foot
------------
  1. 配置在哪里?
    * /etc 下的运行控制文件(配置文件)
    * 有系统设定的环境变量
    * 用户主目录下的控制文件
    * 用户设置的环境变量
    * 启动程序命令行所传递的开关、参数

  ```text
   后面的会覆盖前面的参数
   考虑使用何种机制想程序传递配置数据时候， 要考虑参数的使用周期。
    1. 对调用时可能发生变化项： 使用命令开关。
    2. 改动很少但是确实应该由每个用户控制的项： 用户主目录的运行控制文件
    3. 需要管理员控制，而不是用户能够改变的系统级项： 系统的控制文件
  ```

  2. 运行控制文件（配置文件的格式）
    1. 通常只在程序启动时，一次性读取，因此性能不是主要考虑的问题， 互用性和透明性要求我们使用文本格式。
    2. 特例： 如果程序是某种解释器，那么应该是用 该语言语言写成，并在启动时候，执行命令文件。（mina deploy.rb, 不知道静态语言是不是会费点劲？）

优化： Optimization
--------
  > 关于性能优化， Unix经验告诉我们，最主要的就是如何知道合适不去优化， 其次，最有效的优化往往是优化之外的其他事情，比如干净的设计。

  1. 程序员工具箱中最强大的优化技术就是不做优化
  2. 先估量，后优化。

复杂度： 尽可能简单，但是别简单的过了头（As simple as possible, but Note Simpler）
------------
  | 偶然复杂     | 违反SPOT原则    | 过早优化 | 非正交性
  | :------------- | :------------- |:-------|:---------|
  | 选择复杂度       | 方法学开销       | 别的一切 | 有效功能
  | 本质复杂度 | 开发工具 | 核心数据结构 | 功能需求 |
  |        | 代码库规模 | 实现复杂度 | 接口复杂度 |
  偶然复杂度经常来源于， 接口设计并非正交 
